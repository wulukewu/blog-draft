[{"title":"Docker - Ubuntu SSH Setup","url":"/blog/2024/11/docker-ubuntu-ssh-setup/","content":"Docker - Ubuntu SSH Setup\nHost: Use the same port -&gt; just change to the SSH\nport that does not conflict with NAS.\nEnvironment Settings\nfor Ubuntu Container\nDockerfile\nFROM ubuntu:latestRUN apt-get update &amp;&amp; apt-get install -y openssh-serverRUN mkdir /var/run/sshdRUN echo 'root:your_password' | chpasswdRUN sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_configRUN sed 's@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd# Other installationsRUN apt-get upgrade -yRUN apt-get install -y sudo nano vim curl gitEXPOSE 22CMD [\"/usr/sbin/sshd\", \"-D\"]\nDocker Build and Push to\nDocker Hub\ndocker build -t ubuntu_ssh .docker tag ubuntu_ssh wulukewu/ubuntu_ssh:latestdocker push wulukewu/ubuntu_ssh:latest\nInstall OpenSSH-Server\napt-get update apt-get install -y openssh-servermkdir /var/run/sshdecho 'root:your_password' | chpasswdsed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_configsed 's@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd/usr/sbin/sshd -D\n\nPull and Run the ubuntu_ssh\nImage\nPull ubuntu_ssh from Docker\nHub\nsudo docker pull wulukewu/ubuntu_ssh:latest\nRun ubuntu_ssh in Host\nsudo docker run -d --net=host --name ubuntu_ssh wulukewu/ubuntu_ssh:latest\nAccess the Ubuntu Container\nsudo docker exec -i -t ubuntu_ssh /bin/bash\n\nHostname Configuration\nChange Hostname\nsudo nano /etc/hostnamesudo nano /etc/hostssudo reboot\nDisplay the Current Hostname\nhostname\n\nSSH Configuration\nChange SSH Port\nsudo nano /etc/ssh/sshd_configservice ssh restart\n\nUser Management\nAdd a New Sudo User\nadduser user_name\nAdd the User to the Sudo\nGroup\nusermod -aG sudo user_nameusermod -aG root user_name\nChange User Password\nsudo passwd user_name\nTest Sudo Access\nsu - user_name\n\nReferences\n\nHow\nto SSH into a Docker Container | Step-by-Step Tutorial\nSave\nDocker Image as a File\nUbuntu\nLinux Change Hostname\nDay 21:\nIntroduction to Docker Networking (Part 2)\nDocker\nBasic Commands Cheat Sheet\nHow\nto Create a New Sudo-Enabled User on Ubuntu\nChange\nPassword for Root and User Accounts\nAsk\nChatGPT\n\n","tags":["docker","ubuntu","ssh","devops","containerization","linux","tutorial"]},{"title":"設定GitHub SSH金鑰","url":"/blog/2024/11/github-ssh-key/","content":"Setup\n\n根據email創建一個新的SSH金鑰\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n開啟ssh-agent，將私鑰加入到ssh-agent\neval \"$(ssh-agent -s)\"ssh-add -K ~/.ssh/id_rsa\n上傳公鑰，並到GitHub上上傳SSH key\ncat ~/.ssh/id_rsa.pub GitHub Keys Settings \nssh連接GitHub SSH ssh -T git@github.com\n\nResources\n\n設定 Github\nSSH 金鑰 feat. Github SSH、HTTPS 的差異\nHow to clone, push, and pull\nwith git (beginners GitHub tutorial)\n\n","tags":["ssh","tutorial","github","git","setup"]},{"title":"量子計算基礎 - 從單量子位到多量子位系統","url":"/blog/2025/04/quantum-system/","content":"大一下去修了一門量子計算的課，前面的概念跟線性代數有滿多相似的地方，後半部分才真正開始講量子演算法。\n量子計算基礎簡介\n量子電腦與傳統電腦的差別，在於傳統電腦儲存資訊的最小單位是位元（bit），量子電腦則是使用量子位元（qubit）。位元可以存在一種狀態，1\n或是 0。量子位元特別的地方是，它在一個時間，可以同時是 1 也是 0。\n\n\nbit vs qubit\n\n量子在通訊上有很高的安全性，利用量子力學原理，能夠在兩方之間安全地分發加密密鑰。任何試圖竊聽的行為都會擾亂量子態，被接收方檢測到。\n\n\nquantum application\n\n過去超大整數的質因數分解，即使傳統超級電腦的運算能力也無法在短時間破解。不過，量子演算法（Shor’s\nAlgorithm，可解質因數分解）能在合理時間內完成破解，會顛覆現在 RSA\n等加密算法。\nClassical v.s. Quantum\n拆解質數\n現在有個數字 N = f1 × f2，由\nf1, f2\n兩個很大的質數構成。破解 RSA 的核心，就是從 N 找出 f1 和 f2。\n想要找到 N\n的因數，只要不斷給定 g，透過\nEuclid’s Algorithm（歐幾里得演算法，又稱輾轉相除法）快速計算判斷，當\ng 使得公因數 gcd (N,g) = a &gt; 1\n時，對於 RSA 來說就已經結束了。\n但要找到 g\n可以滿足上述條件其實並不容易，事實上真的只能一個一個猜 g\n是多少。不過，我們可以將這個隨機猜測的數字 g 轉換成很有可能滿足條件的 gp/2 ± 1。\n\n\n為什麼是 gp/2 ± 1 ？\n\n若給定兩個數 A, B，且 gcd (A,B) = 1，則存在一個正整數\np 使得 Ap = m ⋅ B + 1，其中\nm 為某個整數。\n舉兩個例子來說：\nEx1\n給定 (A,B) = (7,15)，則：\n\nEx2\n給定 (A,B) = (42,13)，則：\n\n因此，m ⋅ B = Ap − 1 = (Ap/2+1)(Ap/2−1)\n\n將機會不大的數字 g 轉換成很有可能的gp/2 ± 1，只要找到這樣的p就好（p要是偶數才能真正拆解喔！）\nClassical\n我們用個例子來想，要用傳統電腦找到一個 p 使得 42p = m × 13 + 1，可能會從\np = 1, 2, 3, …\n開始一個一個慢慢代入判斷，但如果現在給定 gp = m × N + 1\n的 g 和 N 都很大呢？\n對傳統電腦來說，就真的只能一個一個數字慢慢算，直到找到答案為止，這也就是為什麼現在能夠這麼廣泛地使用\nRSA 加密。但是對量子電腦來說就不太一樣了……\nQuantum\n用量子來計算的好處是因為有疊加態（superposition）。\n我們可以構建一個 f(x) 的函數。若要計算 a, b, c, d\n各自的函數值，對於傳統電腦來說，就是一個一個代入計算：\nf(a),  f(b),  f(c),  f(d)\n但在量子的世界，可以讓一個或多個量子位元處於疊加態：\n|a⟩+|b⟩ + |c⟩+|d⟩\n然後將這個疊加態輸入設計好的 f(x)\n邏輯閘做平行運算，得到：\n|f(a)⟩+|f(b)⟩ + |f(c)⟩+|f(d)⟩\n\n到這邊還需要先知道另一個 Shor’s Algorithm\n的核心概念。一樣目標是找到滿足條件的 p。如果現在隨便找的一個 x，會得到 gx = mN + r，其中\nr 是餘數，那麼很容易證明 gx + p = m2N + r\n也成立。\n換句話說，對於某個週期 p，gx 模 N 的餘數會重複出現：\ngx mod  N = r ⟹ gx + p mod  N = r\n這個「週期性」就是 Shor’s Algorithm\n能有效率分解質因數的關鍵。只要能找到這個週期 p，就能透過 Quantum Fourier\nTransform（量子傅立葉變換）進一步拆解 N。\n\n\nquantum fourier transform\n\n\n前面提到，在量子的世界中，我們可以構建量子閘，讓所有輸入 x 的餘數 r 同時被計算出來：\n|x⟩→|x⟩|gx mod  N⟩\n這表示，當量子位元處於疊加態時，經過適當設計的量子閘後，所有 x 對應的 gx mod  N\n都會同時存在於量子態中。\n\n\nquantum shor process\n\n從這些餘數當中，任取一個 r，可以經由適當的轉換，將其餘的\nx 都變成 0。最後透過 Fourier Transform 找出的 g = x 和 p，就可以利用前面提過的傳統方式，判斷\ngp/2 ± 1\n是否與 N 有公因數，將 N 拆解開來。\n\n\n標準的 2048 位元 RSA\n加密，就算用目前世界上最強的超級電腦（太湖之光，中國製），花費地球年齡的時間（46\n億年）都無法破解。\n\n如果量子電腦真的存在，能將運算時間由數十億年縮減為幾分、幾秒鐘，數字\nN 都能快速被拆解成 f1, f2\n兩個質數，現在的金融、通訊等都會受到嚴重的影響。但是現在還不需要擔心，因為目前的技術還沒辦法處理太多位元的數字，可能只能拆解\n15 = 3 × 5 這種容易的而已。\n\n單量子位系統\n(Single-Qubit Quantum Systems)\n在量子計算中，量子位元 (Qubit)\n是最基本的資訊單位，類似於傳統計算中的位元\n(Bit)。然而，與傳統位元只能處於 0 或 1 的狀態不同，量子位元可以同時處於\n0 和 1 的疊加態。先來介紹一下量子計算所處於的空間定義：\nHilbert 空間 (Hilbert Space)\n對於單量子位元系統，Hilbert 空間是一個複數 ℂ 中的 inner product\nspace，有向量加法、純量乘法，以及計算向量之間的內積。\n\nIf |ψ⟩,|ϕ⟩ ∈ V, α, β ∈ ℂ, then α|ψ⟩+β|ϕ⟩ ∈ V.\n\n在單量子位元系統當中，我們常用, 當作標準基底，而一個量子位元則可表示為 |ψ⟩=α|0⟩ + β|1⟩。\n至於維度 (Dimension) 為 N\n的向量空間，則會以 {|e1⟩,|e2⟩, …, |eN⟩}\n當作標準基底，也可以寫成{|0⟩,|1⟩, …, |N − 1⟩} 。\n\n\n正規化 (Normalized)：⟨ei|ei⟩=⟨e2|e2⟩ = … = ⟨eN|eN⟩ = 1\n正交 (Orthogoral)：⟨ei|ej⟩=⟨e2|e3⟩ = … = ⟨eN|eN⟩ = 0\n\n因此：\n\nNote：單量子位元系統的 Hilbert 空間是一個 N = 2\n的簡單空間，而複數量子位元系統的 Hilbert\n空間維度會隨著量子位元數量增加而指數成長，例如 n = 5 個量子位元系統的 Hilbert\n空間維度為 N = 25 = 32。\n範例\n我們拿一個例子來說明好了，假設 , ，那麼可以做下列這幾個運算：\n對偶向量 (Dual Vector)\n\n\n\n\n內積 (Inner Product)\n\n\n\n\n因此：\n\n⟨v|v⟩ ∈ ℝ ≥ 0\n(non-negative real)\n\n(a⟨v2|+b⟨v3|)|v1⟩=a⟨v2|v1⟩ + b⟨v3|v1⟩\n\n向量範數 (Norm)\n\n正規化向量 (Normalized\nVector)\n量子態必須是正規化的，以保證測量結果的機率總和為 1。\n\n例如：\n\n計算內積：\n\n\n投影運算子 (Projection\nOperator)\n\n\n\n此時算出的  和  就分別是 |ψ⟩ 在 |e1⟩ 和 |e2⟩\n兩個基底的投影運算子。\n崩塌 (Collapse)\n我們前面說過，|ψ⟩=∑iαi|ei⟩\n是由N維的基底所組成的。其中\n|ei⟩ 在\n|ψ⟩ 出現的機率為 |αi|2，則|α1|2 + |α2|2 + … + |αN|2 = 1。\n在 |ψ⟩=∑iαi|ei⟩\n當中，|ei⟩\n出現的機率取決於 |αi|2，而此時的觀測是不可逆的。當測量完成後，量子態會崩塌到對應的基底態\n|ei⟩，並且無法回復到原本的疊加態。因此測量過程不可逆，且量子態的疊加性在測量後不復存在。\n\n\nQuantum Measurement Single\n\n範例\n\n\n|e1⟩ 在\n|ψ⟩ 出現的機率為 \n|e2⟩ 在\n|ψ⟩ 出現的機率為 \n\n\n量子態 (Quantum State)：\nPi|ψ⟩→|ei⟩\n|ψ⟩=α1|e1⟩ + α2|e2⟩\n經典態 (Classical State)：\n\n\n量子態在測量後會崩塌到某個基底態，而此時的經典態不再具有量子態的疊加性。\nBloch 球 (Bloch Sphere)\nBloch 球用於表示單量子位的狀態：video\n\n\nBloch Sphere\n\n\n\n|0⟩ → (0,0,1)\n|1⟩ → (0,0,−1)\n| + ⟩ → (1,0,0)\n| − ⟩ → (−1,0,0)\n|i⟩ → (0,1,0)\n| − i⟩ → (0,−1,0)\n\nBloch 球上的 I, X, Y, Z\n運算子幾何意義\n\nI (單位運算子)：不改變 Bloch\n球上的狀態（即不旋轉）。\nX 門（Pauli-X）：繞 x 軸旋轉 π 弧度（180°），將 |0⟩ 和 |1⟩\n互換。對應於 Bloch 球上的 x\n軸翻轉。\nY 門（Pauli-Y）：繞 y 軸旋轉 π 弧度（180°），將 |0⟩ 和 |1⟩\n互換，並帶有相位。對應於 Bloch 球上的 y 軸翻轉。\nZ 門（Pauli-Z）：繞 z 軸旋轉 π 弧度（180°），將 | + ⟩ 和 | − ⟩ 互換，|0⟩ 不變，|1⟩ 變號。對應於 Bloch 球上的 z 軸翻轉。\n\n簡單來說，X, Y, Z 分別對應於 Bloch 球上繞 x、y、z 軸的 180° 旋轉。\n\n多量子位系統\n(Multiple-Qubit Systems)\nHilbert 空間與張量積\n(Tensor Product)\n多量子位系統的 Hilbert 空間是單量子位空間的張量積：\nH2 ⊗ H2 ⊗ … ⊗ H2 = HN  (N\n個)\n假設：\n\n第 0 個 H2：{|0⟩0,|1⟩0}\n第 1 個 H2：{|0⟩1,|1⟩1}\n\nTensor Product\nH2 ⊗ H2:\n|ψ1⟩⊗|ψ0⟩ = [α1|0⟩1+β1|1⟩1] ⊗ [α0|0⟩0+β0|1⟩0]\n = α1α0|0⟩1⊗|0⟩0 + α1β0|0⟩1⊗|1⟩0 + β1α0|1⟩1⊗|0⟩0 + β1β0|1⟩1⊗|1⟩0\n = α1α0|00⟩10+α1β0|01⟩10 + β1α0|10⟩10+β1β0|11⟩10\n而此時：\n\n|0⟩1⊗|0⟩0 = |00⟩10\n|0⟩1⊗|1⟩0 = |01⟩10\n|1⟩1⊗|0⟩0 = |10⟩10\n|1⟩1⊗|1⟩0 = |11⟩10\n\n|00⟩,|01⟩, |10⟩,|11⟩ 為 H4 的基底\n範例\n假設：\n\n第 0 個 H2：, , T0 operator\n第 1 個 H2：, , T1 operator\n\n計算張量積：\n\n\n\n\n運算子與單元矩陣\n在多量子位系統中，運算子 T\n和單位運算子 I\n的結合可以用來描述量子態的演化。假設 T0 和 T1\n是作用於不同量子位的運算子，若它們相等，即 T0 = T1 = T，則可以簡化為單一運算子\nT 的作用。\n單位運算子 I\n的作用不會改變量子態，滿足以下關係：\nI|ψ⟩=|ψ⟩\n其中，單位運算子 I\n的矩陣形式為：\n\n當運算子 T\n作用於單一量子位的量子態時，可以表示為：\nT|ψ1⟩,|ψ0⟩\n而當運算子 T 與單位運算子\nI\n結合，作用於多量子位系統的張量積態時，則可以表示為：\n(T⊗I)(|ψ1⟩⊗|ψ0⟩)\n單位運算子：\n\n單元矩陣 (Unitary Matrix)\n假設 U ：\n\n則可發現 U−1 = U†\nNote：共軛轉置 (conjugate) U† = (U*)T\n\n\n\nU 是 Unitary Matrix\n\n量子門與狀態轉換\n(Quantum Gates and State Transformations)\n常見量子門\nH2\n的基本運算子為 I, X, Y, Z\n基本運算子 - X (NOT)\nX|0⟩=|1⟩,  X|1⟩=|0⟩\n\n其中：\nX2 = I = X−1X\nX−1 = X\n基本運算子 - Y\nY|0⟩=+i|1⟩,  Y|1⟩=−i|0⟩\n\n其中：\nY† = Y\n\nY2 = I\nY 是單元矩陣\n基本運算子 - Z\nZ|0⟩=|0⟩,  Z|1⟩=−|1⟩\n\n糾纏態與測量\n在H2中，\nU = αI + βX + γY + δZ\nBell State （貝爾態）\n\n\n\n\nBell State 是兩個 qubit 之間最純粹的糾纏態。\n假設：\n|ψ1⟩=α1|0⟩ + β1|1⟩,  |ψ0⟩ = α0|0⟩+β0|1⟩\n則它們的張量積\n|ψ1⟩⊗|ψ0⟩ = α1α0|00⟩+α1β0|01⟩ + β1α0|10⟩+β1β0|11⟩\n如果 β1α0 = α1β0 = 0，則為\n可分離態；否則為 糾纏態\n(entanglement)。\n糾纏測量\nα1α0|00⟩+β1β0|11⟩ ≠ |ψ1⟩⊗|ψ0⟩\n例如：\n|00⟩+|11⟩ = |0⟩1⊗|0⟩0 + |1⟩1⊗|1⟩0\n\n\nEntangled Measurement\n\n此時去做量子測量：\n\n第 1 個質點測量到 |0⟩，則第 0\n個質點就確定為 |0⟩\n第 1 個質點測量到 |1⟩，則第 0\n個質點就確定為 |1⟩\n\n\n\nQuantum Measurement Multiple\n\n逆向計算 (Reverse\nComputation)\nCNOT (Control NOT)\nCNOT 門的運作如下：\n\n\nCNOT Gate\n\n\nCNOT 性質：\nCNOT ⋅ CNOT = I\nCNOT−1 ⋅ CNOT = I\nCNOT−1 = CNOT\n舉個例子：\n\n\n\n\n\n\n\n1 ⊗ 0 = 1\n1 ⊗ 1 = 0\n\n\n\n\n\n\n\n\n\n這是所有計算中最重要的一個運算門，並且可以延伸出 COPY、NOT 和 SWAP\n三種操作：\n\n\n\n\n\n\n\n\nCOPY\nNOT\nSWAP\n\n\n\n\n\n\n\n\n\n\nCCNOT (Toffoli Gate)\nCCNOT 門的運作如下：\n\n\nCCNOT Gate\n\n\na = 0, b = 0 ⟹ ab = 0 ⟹ |c⊕ab⟩=|c ⊕ 0⟩ = |c⟩\n\n\nCCNOT 性質：\n\n\nCCNOT Reversibility\n\nCCNOT ⋅ CCNOT = I\nCCNOT−1 ⋅ CCNOT = I\nCCNOT−1 = CCNOT\n邏輯運算門\nAND\nAND 的運作如下：\n\n\nAND Gate\n\nXOR\nXOR 的運作如下：\n\n\nXOR Gate\n\nNAND (NOT AND)\nNAND 的運作如下：\n\n\nNAND Gate\n\nNOT\nNOT 也可以用 CNOT 的形式來表示：\n\n\nNOT Gate\n\nOR\nOR 的運作如下：\n\n\nOR Gate\n\n範例\n以下是量子電路的等價性：\n\n\nQuantum Circuit Equivalence\n\n\n量子傳輸\n量子演算法\nBernstein-Vazirani Algorithm\nSimon’s Algorithm\nShor’s Algorithm\nGrover’s Algorithm\n","tags":["quantum","hilbert-space","algorithms","physics"]},{"title":"Vue Basic Syntax","url":"/blog/2025/01/vue-basic-syntax/","content":"Vue Basic Syntax\nDirectives\n\nEvent Binding: v-on or shorthand\n@click\nAttribute Binding: v-bind or shorthand\n:attribute\n\nExamples: :input, :input.enter,\n:key\n\nTwo-Way Binding: v-model\nConditional Rendering:\n\nv-if\nv-else-if\nv-else\nv-show\n\nList Rendering: v-for\n\nExample: v-for=\"goal in goals\"\n\n\nCommunication Between\nComponents\n\nProps: Pass data from parent to child\nEmits: Send events from child to parent\n\n","tags":["tutorial","vue","syntax","basics","guide"]}]